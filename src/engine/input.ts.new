export enum KeyState {
    UP,
    DOWN,
    JUST_PRESSED,
    JUST_RELEASED
}

export class Input {
    private keys: Map<string, KeyState>;
    private previousKeys: Map<string, KeyState>;
    private mouseX: number;
    private mouseY: number;
    private mouseDown: boolean;
    private wheelDelta: number;
    
    constructor() {
        this.keys = new Map();
        this.previousKeys = new Map();
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseDown = false;
        this.wheelDelta = 0;
        
        // Set up event listeners
        window.addEventListener('keydown', (e) => {
            this.onKeyDown(e);
            // Don't prevent default to allow browser functionality to work
        });
        window.addEventListener('keyup', (e) => {
            this.onKeyUp(e);
            // Don't prevent default to allow browser functionality to work
        });
        window.addEventListener('mousemove', (e) => this.onMouseMove(e));
        window.addEventListener('mousedown', () => this.onMouseDown());
        window.addEventListener('mouseup', () => this.onMouseUp());
        window.addEventListener('wheel', (e) => this.onWheel(e));
    }
    
    private onKeyDown(e: KeyboardEvent): void {
        const key = e.key.toLowerCase();
        console.log(`Raw keydown event: key=${key}, code=${e.code}, keyCode=${e.keyCode}`);
        
        // Special handling for P and L keys for debug purposes
        if (key === 'p' || key === 'l') {
            console.log(`DEBUG KEY DETECTED: ${key.toUpperCase()}`);
            
            // FIXED: Always set to JUST_PRESSED regardless of current state to ensure toggles work
            console.log(`Setting ${key.toUpperCase()} to JUST_PRESSED`);
            this.keys.set(key, KeyState.JUST_PRESSED);
            return;
        }
        
        // Standard key handling for all other keys
        // If the key was up previously or not yet registered, mark it as JUST_PRESSED
        const currentState = this.keys.get(key);
        if (currentState !== KeyState.DOWN && currentState !== KeyState.JUST_PRESSED) {
            this.keys.set(key, KeyState.JUST_PRESSED);
        }
    }
    
    private onKeyUp(e: KeyboardEvent): void {
        const key = e.key.toLowerCase();
        
        // Special handling for P and L keys
        if (key === 'p' || key === 'l') {
            console.log(`DEBUG KEY RELEASED: ${key.toUpperCase()}`);
            // FIXED: Set to UP state immediately to allow the key to be pressed again
            this.keys.set(key, KeyState.UP);
            return;
        }
        
        // Mark the key as JUST_RELEASED
        this.keys.set(key, KeyState.JUST_RELEASED);
    }
    
    private onMouseMove(e: MouseEvent): void {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
    }
    
    private onMouseDown(): void {
        this.mouseDown = true;
    }
    
    private onMouseUp(): void {
        this.mouseDown = false;
    }
    
    private onWheel(e: WheelEvent): void {
        // Positive delta means wheel scrolled down (zoom out)
        // Negative delta means wheel scrolled up (zoom in)
        this.wheelDelta = e.deltaY;
        
        // Prevent default scrolling behavior
        e.preventDefault();
    }
    
    public isKeyDown(key: string): boolean {
        const lowercaseKey = key.toLowerCase();
        const state = this.keys.get(lowercaseKey);
        const result = state === KeyState.DOWN || state === KeyState.JUST_PRESSED;
        
        // For movement keys, log the state to help debug
        if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(lowercaseKey)) {
            console.log(`isKeyDown(${lowercaseKey}): ${result} (state: ${state !== undefined ? KeyState[state] : 'undefined'})`);
        }
        
        return result;
    }
    
    public getMousePosition(): { x: number, y: number } {
        return { x: this.mouseX, y: this.mouseY };
    }
    
    public isMouseDown(): boolean {
        return this.mouseDown;
    }
    
    public getWheelDelta(): number {
        const delta = this.wheelDelta;
        // Reset wheel delta after reading it
        this.wheelDelta = 0;
        return delta;
    }
    
    /**
     * Update input state - should be called once per frame
     */
    public update(): void {
        // Store previous key states
        this.previousKeys = new Map(this.keys);
        
        // Process key states that changed this frame
        for (const [key, state] of this.keys.entries()) {
            if (state === KeyState.JUST_PRESSED) {
                // FIXED: Don't change the state of P and L keys here - let the code that checks wasKeyJustPressed do its work
                if (key === 'p' || key === 'l') {
                    // Leave the key in JUST_PRESSED state for now
                    // It will transition to UP in the game's update method after handling
                } else {
                    // For normal keys, move from JUST_PRESSED to DOWN state
                    this.keys.set(key, KeyState.DOWN);
                }
            } else if (state === KeyState.JUST_RELEASED) {
                // Move from JUST_RELEASED to UP state
                this.keys.set(key, KeyState.UP);
            }
        }
    }
    
    /**
     * Check if a key was just pressed this frame
     */
    public wasKeyJustPressed(key: string): boolean {
        const lowercaseKey = key.toLowerCase();
        const currentState = this.keys.get(lowercaseKey);
        const isPressed = currentState === KeyState.JUST_PRESSED;
        
        // Add extra logging for P and L keys
        if (lowercaseKey === 'p' || lowercaseKey === 'l') {
            console.log(`DEBUG: Checking if ${lowercaseKey.toUpperCase()} was just pressed: ${isPressed} (current state: ${currentState !== undefined ? KeyState[currentState] : 'undefined'})`);
            
            // FIXED: If this was checked and it's in JUST_PRESSED state, transition it to UP
            // This ensures it can be pressed again
            if (isPressed) {
                console.log(`Setting ${lowercaseKey.toUpperCase()} to UP after wasKeyJustPressed check`);
                this.keys.set(lowercaseKey, KeyState.UP);
            }
        }
        
        return isPressed;
    }
    
    /**
     * Check if a key was just released this frame
     */
    public wasKeyJustReleased(key: string): boolean {
        return this.keys.get(key.toLowerCase()) === KeyState.JUST_RELEASED;
    }
    
    /**
     * Simulate a key press - for testing purposes
     */
    public simulateKeyPress(key: string): void {
        const lowercaseKey = key.toLowerCase();
        console.log(`Simulating key press for: ${lowercaseKey}`);
        
        // Set the key to JUST_PRESSED state
        this.keys.set(lowercaseKey, KeyState.JUST_PRESSED);
        
        // Immediately notify if this is a P or L key
        if (lowercaseKey === 'p' || lowercaseKey === 'l') {
            console.log(`DEBUG: Simulated ${lowercaseKey.toUpperCase()} key now in JUST_PRESSED state`);
        }
    }
}
